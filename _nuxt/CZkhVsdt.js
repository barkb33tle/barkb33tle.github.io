import{g as L,y as w,m as A,z as q,A as x,c as z,B as V,C as I,k as B,D as U,E as W,G as m,H as M,I as j,J as G,r as J,K as Q,L as X,M as Y,q as Z,N as $,O as K,i as k,P as aa}from"./IDOWRAUd.js";const N=Symbol.for("nuxt:client-only"),ua=L({name:"ClientOnly",inheritAttrs:!1,props:["fallback","placeholder","placeholderTag","fallbackTag"],setup(a,{slots:e,attrs:i}){const o=w(!1);A(()=>{o.value=!0});const n=V();return n&&(n._nuxtClientOnly=!0),I(N,!0),()=>{if(o.value){const _=e.default?.();return _&&_.length===1?[q(_[0],i)]:_}const D=e.fallback||e.placeholder;if(D)return x(D);const r=a.fallback||a.placeholder||"",t=a.fallbackTag||a.placeholderTag||"span";return z(t,i,r)}}}),ea={trailing:!0};function ta(a,e=25,i={}){if(i={...ea,...i},!Number.isFinite(e))throw new TypeError("Expected `wait` to be a finite number");let o,n,D=[],r,t;const _=(f,b)=>(r=na(a,f,b),r.finally(()=>{if(r=null,i.trailing&&t&&!n){const g=_(f,t);return t=null,g}}),r),y=function(...f){return i.trailing&&(t=f),r||new Promise(b=>{const g=!n&&i.leading;clearTimeout(n),n=setTimeout(()=>{n=null;const l=i.leading?o:_(this,f);t=null;for(const d of D)d(l);D=[]},e),g?(o=_(this,f),b(o)):D.push(b)})},s=f=>{f&&(clearTimeout(f),n=null)};return y.isPending=()=>!!n,y.cancel=()=>{s(n),D=[],t=null},y.flush=()=>{if(s(n),!t||r)return;const f=t;return t=null,_(this,f)},y}async function na(a,e,i){return await a.apply(e,i)}const ra=a=>a==="defer"||a===!1;function fa(...a){const e=typeof a[a.length-1]=="string"?a.pop():void 0;sa(a[0],a[1])&&a.unshift(e);let[i,o,n={}]=a,D=!1;const r=B(()=>U(i));if(typeof r.value!="string")throw new TypeError("[nuxt] [useAsyncData] key must be a string.");if(typeof o!="function")throw new TypeError("[nuxt] [useAsyncData] handler must be a function.");const t=W();n.server??=!0,n.default??=ia,n.getCachedData??=F,n.lazy??=!1,n.immediate??=!0,n.deep??=m.deep,n.dedupe??="cancel",n._functionName,t._asyncData[r.value];function _(){const l={cause:"initial",dedupe:n.dedupe};return t._asyncData[r.value]?._init||(l.cachedData=n.getCachedData(r.value,t,{cause:"initial"}),t._asyncData[r.value]=T(t,r.value,o,n,l.cachedData)),()=>t._asyncData[r.value].execute(l)}const y=_(),s=t._asyncData[r.value];s._deps++;const f=n.server!==!1&&t.payload.serverRendered;{let l=function(u){const c=t._asyncData[u];c?._deps&&(c._deps--,c._deps===0&&c?._off())};const d=V();if(d&&f&&n.immediate&&!d.sp&&(d.sp=[]),d&&!d._nuxtOnBeforeMountCbs){d._nuxtOnBeforeMountCbs=[];const u=d._nuxtOnBeforeMountCbs;$(()=>{u.forEach(c=>{c()}),u.splice(0,u.length)}),K(()=>u.splice(0,u.length))}const p=d&&(d._nuxtClientOnly||k(N,!1));f&&t.isHydrating&&(s.error.value||s.data.value!=null)?(s.pending.value=!1,s.status.value=s.error.value?"error":"success"):d&&(!p&&t.payload.serverRendered&&t.isHydrating||n.lazy)&&n.immediate?d._nuxtOnBeforeMountCbs.push(y):n.immediate&&y();const h=G(),v=M(r,(u,c)=>{if((u||c)&&u!==c){D=!0;const O=t._asyncData[c]?.data.value!==m.value,H=t._asyncDataPromises[c]!==void 0,S={cause:"initial",dedupe:n.dedupe};if(!t._asyncData[u]?._init){let E;c&&O?E=t._asyncData[c].data.value:(E=n.getCachedData(u,t,{cause:"initial"}),S.cachedData=E),t._asyncData[u]=T(t,u,o,n,E)}t._asyncData[u]._deps++,c&&l(c),(n.immediate||O||H)&&t._asyncData[u].execute(S),aa(()=>{D=!1})}},{flush:"sync"}),C=n.watch?M(n.watch,()=>{D||s._execute({cause:"watch",dedupe:n.dedupe})}):()=>{};h&&j(()=>{v(),C(),l(r.value)})}const b={data:P(()=>t._asyncData[r.value]?.data),pending:P(()=>t._asyncData[r.value]?.pending),status:P(()=>t._asyncData[r.value]?.status),error:P(()=>t._asyncData[r.value]?.error),refresh:(...l)=>t._asyncData[r.value]?._init?t._asyncData[r.value].execute(...l):_()(),execute:(...l)=>b.refresh(...l),clear:()=>{const l=t._asyncData[r.value];if(l?._abortController)try{l._abortController.abort(new DOMException("AsyncData aborted by user.","AbortError"))}finally{l._abortController=void 0}R(t,r.value)}},g=Promise.resolve(t._asyncDataPromises[r.value]).then(()=>b);return Object.assign(g,b),g}function P(a){return B({get(){return a()?.value},set(e){const i=a();i&&(i.value=e)}})}function sa(a,e){return!(typeof a=="string"||typeof a=="object"&&a!==null||typeof a=="function"&&typeof e=="function")}function R(a,e){e in a.payload.data&&(a.payload.data[e]=void 0),e in a.payload._errors&&(a.payload._errors[e]=m.errorValue),a._asyncData[e]&&(a._asyncData[e].data.value=void 0,a._asyncData[e].error.value=m.errorValue,a._asyncData[e].pending.value=!1,a._asyncData[e].status.value="idle"),e in a._asyncDataPromises&&(a._asyncDataPromises[e]=void 0)}function oa(a,e){const i={};for(const o of e)i[o]=a[o];return i}function T(a,e,i,o,n){a.payload._errors[e]??=m.errorValue;const D=o.getCachedData!==F,r=i,t=o.deep?J:w,_=n!=null,y=a.hook("app:data:refresh",async f=>{(!f||f.includes(e))&&await s.execute({cause:"refresh:hook"})}),s={data:t(_?n:o.default()),pending:w(!_),error:Q(a.payload._errors,e),status:w("idle"),execute:(...f)=>{const[b,g=void 0]=f,l=b&&g===void 0&&typeof b=="object"?b:{};if(a._asyncDataPromises[e]&&ra(l.dedupe??o.dedupe))return a._asyncDataPromises[e];if(l.cause==="initial"||a.isHydrating){const h="cachedData"in l?l.cachedData:o.getCachedData(e,a,{cause:l.cause??"refresh:manual"});if(h!=null)return a.payload.data[e]=s.data.value=h,s.error.value=m.errorValue,s.status.value="success",Promise.resolve(h)}s.pending.value=!0,s._abortController&&s._abortController.abort(new DOMException("AsyncData request cancelled by deduplication","AbortError")),s._abortController=new AbortController,s.status.value="pending";const d=new AbortController,p=new Promise((h,v)=>{try{const C=l.timeout??o.timeout,u=la([s._abortController?.signal,l?.signal],d.signal,C);if(u.aborted){const c=u.reason;v(c instanceof Error?c:new DOMException(String(c??"Aborted"),"AbortError"));return}return u.addEventListener("abort",()=>{const c=u.reason;v(c instanceof Error?c:new DOMException(String(c??"Aborted"),"AbortError"))},{once:!0,signal:d.signal}),Promise.resolve(r(a,{signal:u})).then(h,v)}catch(C){v(C)}}).then(async h=>{let v=h;o.transform&&(v=await o.transform(h)),o.pick&&(v=oa(v,o.pick)),a.payload.data[e]=v,s.data.value=v,s.error.value=m.errorValue,s.status.value="success"}).catch(h=>{if(!(a._asyncDataPromises[e]&&a._asyncDataPromises[e]!==p)&&!s._abortController?.signal.aborted){if(typeof DOMException<"u"&&h instanceof DOMException&&h.name==="AbortError"){s.status.value="idle";return}s.error.value=Y(h),s.data.value=Z(o.default()),s.status.value="error"}}).finally(()=>{s.pending.value=!1,d.abort(),delete a._asyncDataPromises[e]});return a._asyncDataPromises[e]=p,a._asyncDataPromises[e]},_execute:ta((...f)=>s.execute(...f),0,{leading:!0}),_default:o.default,_deps:0,_init:!0,_hash:void 0,_off:()=>{y(),a._asyncData[e]?._init&&(a._asyncData[e]._init=!1),D||X(()=>{a._asyncData[e]?._init||(R(a,e),s.execute=()=>Promise.resolve(),s.data.value=m.value)})}};return s}const ia=()=>m.value,F=(a,e,i)=>{if(e.isHydrating)return e.payload.data[a];if(i.cause!=="refresh:manual"&&i.cause!=="refresh:hook")return e.static.data[a]};function la(a,e,i){const o=a.filter(r=>!!r);if(typeof i=="number"&&i>=0){const r=AbortSignal.timeout?.(i);r&&o.push(r)}if(AbortSignal.any)return AbortSignal.any(o);const n=new AbortController;for(const r of o)if(r.aborted){const t=r.reason??new DOMException("Aborted","AbortError");try{n.abort(t)}catch{n.abort()}return n.signal}const D=()=>{const t=o.find(_=>_.aborted)?.reason??new DOMException("Aborted","AbortError");try{n.abort(t)}catch{n.abort()}};for(const r of o)r.addEventListener?.("abort",D,{once:!0,signal:e});return n.signal}export{ua as _,fa as u};
